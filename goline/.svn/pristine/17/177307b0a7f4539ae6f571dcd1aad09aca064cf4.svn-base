package server

import (
	"strings"
	"time"
	"strconv"
	"bufio"
	"io"
	"goline/trainer"
	"goline/predictor"
	"goline/util"
	"io/ioutil"
	"os"
	"net/http"
	"fmt"
	"errors"
	"encoding/json"
	s"strings"
)

type Lands struct {
//	pool    *redis.Pool
	mux 	map[string]func(http.ResponseWriter, *util.ModelParam) error
	conf	*Config
}

type Config struct {
	DataPathBase		string		`json:"DataPathBase"`
	LineSpliter			string		`json:"LineSpliter"`	//online learning instance spliter.
	SampleSpliter		string		`json:"SampleSpliter"`	//instance spliter between features.
}

const (
	JsonError = "{\"returncode\": 1,\"message\": \"%s\",\"result\": []}"
	TimeFormatString = "200601021504"
)

func (lan *Lands) Initialize(configFile string) error{
	lan.mux = make(map[string]func(http.ResponseWriter, *util.ModelParam) error)
    lan.mux["/online"] = lan.onlineServeHttp
    lan.mux["/offline"] = lan.offlineServeHttp
	
	file, err := ioutil.ReadFile(configFile)
	if err != nil {
		return errors.New("[Initialize]Open Config error.")
	}

	temp := new(Config)
	if err = json.Unmarshal(file, temp); err != nil {
		return errors.New("[Initialize]Parse config file error.")
	}
	
	lan.conf = temp
	
	return nil
}

func (lan *Lands) checkData(filename string) error{
	count := 0
	fs, err := os.Open(filename)
	if err != nil {
		return errors.New("[OpenFile] Open file failed.")
	}
	
	defer fs.Close()
	
	buf :=bufio.NewReader(fs)
	
	line, err := buf.ReadString('\n')
	line = s.TrimSpace(line)
	sp := s.Split(line, lan.conf.SampleSpliter)
	count++
	if len(sp) <= 1 {
		str := fmt.Sprintf("[spliter must be space] file %s,line %d,content %s", filename, count, line)
		return errors.New(fmt.Sprintf(JsonError, str))	//分隔符错误(不是space)
	}
	
	label, err := strconv.Atoi(sp[0])
	if err != nil || (label != 0 && label != 1) {
		str := fmt.Sprintf("[label must be 0/1] file %s,line %d,content %s", filename, count, sp[0])
		return errors.New(fmt.Sprintf(JsonError, str))	//标注错误(不是0或1)
	}
	
	for i:=1; i<len(sp); i++ {
		tup := s.Split(sp[i], ":")
		if len(tup) != 2 {
			str := fmt.Sprintf("[feature value must be key:value] file %s,line %d,content %s", filename, count, sp[i])
			return errors.New(fmt.Sprintf(JsonError, str))	//特征格式错误(不是key:value)	
		}
	}
	
  	if err != nil { //遇到任何错误立即返回，并忽略 EOF 错误信息
   		if err == io.EOF {
    		return nil
		} else {
			return err
		}
	}
	
	return nil
}

/*
 * 在线模型请求串格式
 * http://127.0.0.1:8080/online?biz=[model name]&src=[redis&stream]&dst=[redis&local&json]
                &epoch=[2]&threads=[threads number]&train=[redis key/instance strings]
				&debug=[off]&thd=[threshold]
   src:训练数据为redis还是即时stream (初始化模型如果redis不存在则读取local,模型key为biz值)
   dst:模型存储到redis、local和json
   train:训练数据来源于redis或stream
*/
func (lan *Lands) onlineServeHttp(w http.ResponseWriter, par *util.ModelParam) error {
//	instances := []string {"0 40:1 91:1 145:1 195:1 244:1 294:1 340:1 374:1 404:1 460:1 500:1 556:1 608:1 611:1 661:1 711:1 799:1",
//	"0 47:1 97:1 144:1 198:1 246:1 299:1 347:1 377:1 408:1 457:1 510:1 537:1 610:1 659:1 703:1 757:1 788:1",
//	"1 1:1 51:1 101:1 151:1 201:1 251:1 301:1 351:1 381:1 411:1 461:1 556:1 561:1 647:1 699:1 711:1 808:1",
//	"1 1:1 51:1 101:1 151:1 201:1 251:1 301:1 351:1 381:1 411:1 461:1 556:1 561:1 647:1 699:1 711:1 808:1",
//	"0 48:1 98:1 145:1 194:1 242:1 289:1 347:1 377:1 405:1 411:1 461:1 550:1 561:1 611:1 701:1 711:1 805:1",
//	"0 37:1 88:1 137:1 190:1 239:1 292:1 341:1 376:1 407:1 439:1 509:1 529:1 607:1 643:1 685:1 753:1 793:1"}
	
	var base_path_on string
	var wr io.Writer
	if par.Debug == "on"{
		wr = w
	} else if par.Debug == "off"{
		wr = os.Stdout
	}
	
	base_path_on = lan.conf.DataPathBase + par.Biz + "/on/"
	
	timestamp := time.Now().Format(TimeFormatString)
	err := util.Mkdir(base_path_on + "/" + timestamp) 
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return err
	}
	
	base_path_ws := base_path_on + "workspace/"
	
	err = util.Mkdir(base_path_ws) 
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return err
	}
	
	//读取离线模型
	//优先读取redis
	//读取失败则读本地模型
	fs, err := os.Open(base_path_ws + "model.dat")
	if err != nil {
		return errors.New("[onlineServeHttp] offline model must be trained.")
	}
	
	defer fs.Close()
	
	buf :=bufio.NewReader(fs)
	
	line, err := buf.ReadString('\n')
	encodemodel := s.TrimSpace(line)
  	if err != nil && err != io.EOF{ //遇到任何错误立即返回，并忽略 EOF 错误信息
		return errors.New("[onlineServeHttp] Open offline model error.")
	}
	
	//模型训练
	var lff trainer.LockFreeFtrlTrainer
	lff.SetJobName(par.Biz + " online " + timestamp)
	lff.Initialize(par.Epoch,par.Threads,false)
	instances := strings.Split(par.Train, lan.conf.LineSpliter)
	model, err := lff.TrainOnline(wr,encodemodel,instances, fmt.Fprintf)
	if err != nil {
		return  errors.New("[onlineServeHttp] online model training error."+err.Error())
	}
	
	//模型写入本地
	util.CopyFile(base_path_ws + "model_bak.dat", base_path_ws + "model.dat")
	fout, err := os.OpenFile(base_path_on + "/" + timestamp + "/model.dat", os.O_TRUNC|os.O_WRONLY|os.O_CREATE, 0644)
    defer fout.Close()
    if err != nil {
        return errors.New("[onlineServeHttp] online model write local error.")
    }
	
	fout.WriteString(model)	
	err = util.CopyFile(base_path_ws + "model.dat", base_path_on + "/" + timestamp + "/model.dat")
	if err != nil {
		return err
	}
	
	//模型写入redis
	//key := par.Biz
	
	//清理目录
	util.KeepLatestN(base_path_on, 5)
	
	//接口输出
	fmt.Fprintf(w, model)
	
	return nil
}

/*
 * 离线模型请求串格式
 * http://127.0.0.1:8080/offline?biz=[model name]&src=[hdfs/local]&dst=[redis&local&json]
                &alpha=[0.1]&beta=[0.1]&l1=[10]&l2=[10]&dropout=[0.1]&epoch=[2]
				&push=[push step]&fetch=[fetch step]&threads=[threads number]
				&train=[train file name]&test=[test file name]&debug=[off]&thd=[threshold]
   src:训练、测试数据源为hdfs/local
   dst:模型输出到redis、local和json
   train:训练数据完整路径
   test:测试数据完整路径
*/
func (lan *Lands) offlineServeHttp(w http.ResponseWriter, par *util.ModelParam) error {
	var base_path_off, model_path, train_path, test_path string
	var predict_path string
	var wr io.Writer
	if par.Debug == "on"{
		wr = w
	} else if par.Debug == "off"{
		wr = os.Stdout
	}
	
	//建立模型训练本地路径
	base_path_off = lan.conf.DataPathBase + par.Biz + "/off/"
	
	timestamp := time.Now().Format(TimeFormatString)
	err := util.Mkdir(base_path_off + "/" + timestamp) 
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return err
	}
	
	base_path_on := lan.conf.DataPathBase + par.Biz + "/on/workspace"
	
	err = util.Mkdir(base_path_on) 
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return err
	}
	
	//挂载数据
	if par.Src == "hdfs" {
				
	} else if par.Src == "local" {
		model_path = base_path_off + "/" + timestamp + "/model.dat"
		train_path = base_path_off + "/" + timestamp + "/train.dat"
		test_path = base_path_off + "/" + timestamp + "/test.dat"
		predict_path = base_path_off + "/" + timestamp + "/predict.dat"
		err := util.CopyFile(train_path, par.Train)
		if err != nil {
			return err
		}
		err = util.CopyFile(test_path, par.Test)
		if err != nil {
			return err
		}
		
		fmt.Fprintf(wr, "model path=%s,train path=%s, test path=%s\n", 
					model_path,
					train_path,
					test_path)
	}
	
	//训练数据格式检查及转换
	err = lan.checkData(train_path)
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return err
	}
	err = lan.checkData(test_path)
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return err
	}

	//模型训练
	var fft trainer.FastFtrlTrainer
	fft.SetJobName(par.Biz + " offline " + timestamp)
	fft.Initialize(par.Epoch, par.Threads, false, 1, par.Push, par.Fetch)
	fft.Train(wr,par.Alpha,par.Beta,par.L1,par.L2,par.Dropout,model_path,
				train_path,
				test_path, fmt.Fprintf)
	

	predictor.Run(wr, 3,[]string{par.Biz + " offline " + timestamp, test_path,
				model_path,
				predict_path,
				par.Threshold}, fmt.Fprintf)
	
	err = util.CopyFile(base_path_on + "/model.dat", base_path_off + "/" + timestamp + "/model.dat")
	if err != nil {
		return err
	}		
		
	//模型输出
	if par.Dst == "redis" {
		//key := par.Biz
		
	}
	
	//清理目录
	util.KeepLatestN(base_path_off, 5)
	
	fmt.Fprintf(w,"%s",fft.ParamServer.SaveEncodeModel())	
	
	return nil
}

func (lan *Lands) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	par := util.ParamParse(r)
 	if h, ok := lan.mux[par.Module]; ok {
        h(w, par)
    }

//    t0 := time.Now()

//    log4pv := lan.log4pv
//    log4sys := util.GetLogger()
//    log4sys.Info("Receive request: %s", r.URL.RawQuery)

//    if r.Method != "POST" {
//	fmt.Fprintf(w, ERR_MSG, "Only POST method supported")
//	return
//    }

//    var req LandsRequest
//    var res LandsResponse
//    var info_in RankInfoIn
//    var info_out RankInfoOut

//    body, err := ioutil.ReadAll(r.Body)
//    if err != nil {
//	fmt.Fprintf(w, ERR_MSG, "Read http body error")
//	return
//    }

//    // decoder := json.NewDecoder(r.Body)
//    // err := decoder.Decode(&req)
//    err = json.Unmarshal(body, &req)
//    if err != nil {
//	log4sys.Error(string(body), err)
//	fmt.Fprintf(w, ERR_MSG, "Json format error")
//	return
//    }

//    r.ParseForm()

//    // If "_callback" exists in url, http response is jsonp; 
//    // otherwise http response is json.
//    var callback string
//    s := r.Form["_callback"]
//    if len(s) != 0 {
//	callback = s[0]
//    }

//    err = lan.fillInfoList(&info_in, &req)
//    if err != nil {
//	log4sys.Error("[fillInfoList]", err)
//	Logging(&req, nil, nil, log4pv)
//	msg := fmt.Sprintf(ERR_MSG, "Internal server error")
//	httpResponse(w, callback, msg)
//	return
//    }

//    ranker := lan.askPriceRanker
//    err = ranker.Rank(&info_in, &info_out)
//    if err != nil {
//	log4sys.Error("[Rank]", err)
//	Logging(&req, nil, nil, log4pv)
//	msg := fmt.Sprintf(ERR_MSG, "Internal server error")
//	httpResponse(w, callback, msg)
//	return
//    }

//    lan.parseInfoList(&info_out, &res)

//    b, err := json.Marshal(res)
//    if err != nil {
//	log4sys.Error(err)
//	Logging(&req, &res, &info_out, log4pv)
//	msg := fmt.Sprintf(ERR_MSG, "Internal server error")
//	httpResponse(w, callback, msg)
//	return
//    }

//    Logging(&req, &res, &info_out, log4pv)

//    total_time := time.Now().Sub(t0)
//    log4sys.Debug("Spend total time", total_time)
//    if(total_time > lan.thresTime) {
//	log4sys.Error("Spend total time exceed %d", lan.thresTime)
//    }

//    httpResponse(w, callback, string(b))
}