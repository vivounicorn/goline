package server

import (
	"bufio"
	"encoding/json"
	"errors"
	"fmt"
	"goline/hdfs"
	"goline/predictor"
	"goline/trainer"
	"goline/util"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"strconv"
	"strings"
	s "strings"
	"time"
)

type Lands struct {
	//	pool    *redis.Pool
	mux  map[string]func(http.ResponseWriter, *util.ModelParam) error
	conf *Config
}

type Config struct {
	DataPathBase  string `json:"DataPathBase"`
	LineSpliter   string `json:"LineSpliter"`   //online learning instance spliter.
	SampleSpliter string `json:"SampleSpliter"` //instance spliter between features.
	HadoopUser    string `json:"HadoopUser"`
	NameNodes     string `json:"NameNodes"`
}

const (
	JsonError        = "{\"returncode\": 1,\"message\": \"%s\",\"result\": []}"
	TimeFormatString = "200601021504"
)

func (lan *Lands) Initialize(configFile string) error {

	var err error
	lan.mux = make(map[string]func(http.ResponseWriter, *util.ModelParam) error)
	lan.mux["/online"] = lan.onlineServeHttp
	lan.mux["/offline"] = lan.offlineServeHttp
	lan.mux["/predict"] = lan.predictServeHttp

	file, err := ioutil.ReadFile(configFile)
	if err != nil {
		return errors.New("[Lands-Initialize]Open Config error.")
	}

	temp := new(Config)
	if err = json.Unmarshal(file, temp); err != nil {
		return errors.New("[Lands-Initialize]Parse config file error.")
	}

	lan.conf = temp

	return nil
}

func (lan *Lands) createHdfsClient() (*hdfs.Client, error) {
	var err error
	var client *hdfs.Client
	namenodes := strings.Split(lan.conf.NameNodes, ",")
	for i := range namenodes {
		client, err = hdfs.NewForUser(namenodes[i]+":8020", lan.conf.HadoopUser)
		if err == nil {
			break
		}
	}

	if err != nil {
		return nil, errors.New("[Lands-Initialize]Create hdfs client error.")
	}

	return client, nil
}

func (lan *Lands) checkData(filename string) (int64, error) {
	var count int64 = 0
	fs, err := os.Open(filename)
	if err != nil {
		return 0, errors.New("[Lands-OpenFile] Open file failed.")
	}

	defer fs.Close()

	buf := bufio.NewReader(fs)

	for {
		line, err := buf.ReadString('\n')
		if err != nil { //遇到任何错误立即返回，并忽略 EOF 错误信息
			if err == io.EOF {
				return count, nil
			} else {
				return 0, err
			}
		}
		line = s.TrimSpace(line)
		sp := s.Split(line, lan.conf.SampleSpliter)
		count++
		if len(sp) <= 1 {
			str := fmt.Sprintf("[spliter must be space] file %s,line %d,content %s", filename, count, line)
			return 0, errors.New(fmt.Sprintf(JsonError, str)) //分隔符错误(不是space)
		}

		label, err := strconv.ParseFloat(sp[0], 64)
		if err != nil || (int(label) != 0 && int(label) != 1) {
			str := fmt.Sprintf("[label must be 0/1] file %s,line %d,content %s", filename, count, sp[0])
			return 0, errors.New(fmt.Sprintf(JsonError, str)) //标注错误(不是0或1)
		}

		for i := 1; i < len(sp); i++ {
			tup := s.Split(sp[i], ":")
			if len(tup) != 2 {
				str := fmt.Sprintf("[feature value must be key:value] file %s,line %d,content %s", filename, count, sp[i])
				return 0, errors.New(fmt.Sprintf(JsonError, str)) //特征格式错误(不是key:value)
			}
		}
	}

	return count, nil
}

/*
 * 在线模型请求串格式
 * http://127.0.0.1:8080/online?biz=[model name]&src=[redis&stream]&dst=[redis&local&json]
                &epoch=[2]&threads=[threads number]&train=[redis key/instance strings]
				&debug=[off]&thd=[threshold]
   src:训练数据为redis还是即时stream (初始化模型如果redis不存在则读取local,模型key为biz值)
   dst:模型存储到redis、local和json
   train:训练数据来源于redis或stream
*/
func (lan *Lands) onlineServeHttp(w http.ResponseWriter, par *util.ModelParam) error {
	var base_path_on string
	var wr io.Writer
	if par.Debug == "on" {
		wr = w
	} else if par.Debug == "off" {
		wr = os.Stdout
	}

	base_path_on = lan.conf.DataPathBase + par.Biz + "/on/"

	timestamp := time.Now().Format(TimeFormatString)
	err := util.Mkdir(base_path_on + "/" + timestamp)
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return err
	}

	base_path_ws := base_path_on + "workspace/"

	err = util.Mkdir(base_path_ws)
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return err
	}

	//读取离线模型
	//优先读取redis
	//读取失败则读本地模型
	fs, err := os.Open(base_path_ws + "model.dat")
	if err != nil {
		return errors.New("[Lands-onlineServeHttp] offline model must be trained." + err.Error())
	}

	defer fs.Close()

	buf := bufio.NewReader(fs)

	line, err := buf.ReadString('\n')
	encodemodel := s.TrimSpace(line)
	if err != nil && err != io.EOF { //遇到任何错误立即返回，并忽略 EOF 错误信息
		return errors.New("[Lands-onlineServeHttp] Open offline model error." + err.Error())
	}

	//模型训练
	var lff trainer.LockFreeFtrlTrainer
	lff.SetJobName(par.Biz + " online " + timestamp)
	if !lff.Initialize(par.Epoch, par.Threads, false) {
		return errors.New("[Lands-onlineServeHttp] Initialize offline model error.")
	}
	instances := strings.Split(par.Train, lan.conf.LineSpliter)
	if len(instances) == 0 {
		return errors.New("[Lands-onlineServeHttp] Instances number error.")
	}
	model, err := lff.TrainOnline(wr, encodemodel, instances, fmt.Fprintf)
	if err != nil {
		return errors.New("[Lands-onlineServeHttp] online model training error." + err.Error())
	}

	//模型写入本地
	util.CopyFile(base_path_ws+"model_bak.dat", base_path_ws+"model.dat")
	fout, err := os.OpenFile(base_path_on+"/"+timestamp+"/model.dat", os.O_TRUNC|os.O_WRONLY|os.O_CREATE, 0644)
	defer fout.Close()
	if err != nil {
		return errors.New("[Lands-onlineServeHttp] online model write local error." + err.Error())
	}

	fout.WriteString(model)
	err = util.CopyFile(base_path_ws+"model.dat", base_path_on+"/"+timestamp+"/model.dat")
	if err != nil {
		return errors.New("[Lands-onlineServeHttp] Copy model error." + err.Error())
	}

	//模型写入redis
	//key := par.Biz

	//清理目录
	err = util.KeepLatestN(base_path_on, 5)
	if err != nil {
		errors.New("[Lands-onlineServeHttp] Clear local file error." + err.Error())
	}

	//接口输出
	fmt.Fprintf(w, model)

	return nil
}

/*
 * 离线模型请求串格式
 * http://127.0.0.1:8080/offline?biz=[model name]&src=[hdfs/local]&dst=[redis&local&json]
                &alpha=[0.1]&beta=[0.1]&l1=[10]&l2=[10]&dropout=[0.1]&epoch=[2]
				&push=[push step]&fetch=[fetch step]&threads=[threads number]
				&train=[train file name]&test=[test file name]&debug=[off]&thd=[threshold]
   src:训练、测试数据源为hdfs/local
   dst:模型输出到redis、local和json
   train:训练数据完整路径
   test:测试数据完整路径
*/
func (lan *Lands) offlineServeHttp(w http.ResponseWriter, par *util.ModelParam) error {
	var base_path_off, model_path, train_path, test_path string
	var predict_path string
	var wr io.Writer
	if par.Debug == "on" {
		wr = w
	} else if par.Debug == "off" {
		wr = os.Stdout
	}

	//建立模型训练本地路径
	base_path_off = lan.conf.DataPathBase + par.Biz + "/off/"

	timestamp := time.Now().Format(TimeFormatString)
	err := util.Mkdir(base_path_off + "/" + timestamp)
	if err != nil {
		return errors.New("[Lands-offlineServeHttp] offline model make local directory error." + err.Error())
	}

	base_path_on := lan.conf.DataPathBase + par.Biz + "/on/workspace"

	err = util.Mkdir(base_path_on)
	if err != nil {
		return errors.New("[Lands-offlineServeHttp] Make online local workspace directory error." + err.Error())
	}

	//挂载数据
	if par.Src == "hdfs" {
		client, err := lan.createHdfsClient()
		if err != nil {
			return errors.New("[Lands-offlineServeHttp] Create hdfs client error." + err.Error())
		}

		model_path = base_path_off + "/" + timestamp + "/model.dat"
		train_path = base_path_off + "/" + timestamp + "/train.dat"
		test_path = base_path_off + "/" + timestamp + "/test.dat"
		predict_path = base_path_off + "/" + timestamp + "/predict.dat"

		client.GetMerge(par.Train, train_path, true)
		if err != nil {
			return errors.New("[Lands-offlineServeHttp] Getmerge train data from hdfs to local error." + err.Error())
		}

		client.GetMerge(par.Test, test_path, true)
		if err != nil {
			return errors.New("[Lands-offlineServeHttp] Getmerge test data from hdfs to local error." + err.Error())
		}

	} else if par.Src == "local" {
		model_path = base_path_off + "/" + timestamp + "/model.dat"
		train_path = base_path_off + "/" + timestamp + "/train.dat"
		test_path = base_path_off + "/" + timestamp + "/test.dat"
		predict_path = base_path_off + "/" + timestamp + "/predict.dat"
		err := util.CopyFile(train_path, par.Train)
		if err != nil {
			return errors.New("[Lands-offlineServeHttp] copy train data from local to local error." + err.Error())
		}
		err = util.CopyFile(test_path, par.Test)
		if err != nil {
			return errors.New("[Lands-offlineServeHttp] copy test data from local to local error." + err.Error())
		}
	}

	fmt.Fprintf(wr, "model path=%s,train path=%s, test path=%s\n",
		model_path,
		train_path,
		test_path)

	//训练数据格式检查及转换
	_, err = lan.checkData(train_path)
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return errors.New("[Lands-offlineServeHttp] Check train data from local to local error." + err.Error())
	}
	_, err = lan.checkData(test_path)
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return errors.New("[Lands-offlineServeHttp] Check test data from local to local error." + err.Error())
	}

	//数据抽样
	err = util.FileSampleWithRatio(train_path, par.Sample)
	if err != nil {
		return errors.New("[Lands-offlineServeHttp] Train data sampling error." + err.Error())
	}

	//模型训练
	var fft trainer.FastFtrlTrainer
	fft.SetJobName(par.Biz + " offline " + timestamp)
	if !fft.Initialize(par.Epoch, par.Threads, false, 1, par.Push, par.Fetch) {
		return errors.New("[Lands-offlineServeHttp] Initialize ftrl trainer error.")
	}

	err = fft.Train(wr, par.Alpha, par.Beta, par.L1, par.L2, par.Dropout, model_path,
		train_path, test_path, fmt.Fprintf)
	if err != nil {
		return errors.New("[Lands-offlineServeHttp] Training model error." + err.Error())
	}

	predictor.Run(wr, 3, []string{par.Biz + " offline " + timestamp, test_path,
		model_path,
		predict_path,
		par.Threshold}, fmt.Fprintf)

	err = util.CopyFile(base_path_on+"/model.dat", base_path_off+"/"+timestamp+"/model.dat")
	if err != nil {
		return err
	}

	//模型输出
	if par.Dst == "redis" {
		//key := par.Biz

	}

	//清理目录
	util.KeepLatestN(base_path_off, 5)

	m, err := fft.ParamServer.SaveEncodeModel()
	if err != nil {
		return err
	}

	fmt.Fprintf(w, "%s", m)

	return nil
}

/*
 * 离线模型请求串格式
 * http://127.0.0.1:8080/predict?biz=[model name]&src=[hdfs/redis/stream]&dst=[local&json]
				&pred=[hdfs file/redis key/instance strings]&debug=[off]&thd=[threshold]
   src:待预测数据源为hdfs/local
   dst:待预测数据输出到local和json
   pred:待预测数据完整路径
*/
func (lan *Lands) predictServeHttp(w http.ResponseWriter, par *util.ModelParam) error {
	var predict_path string
	var wr io.Writer
	if par.Debug == "on" {
		wr = w
	} else if par.Debug == "off" {
		wr = os.Stdout
	}

	base_path_prd := lan.conf.DataPathBase + par.Biz + "/prd/"

	timestamp := time.Now().Format(TimeFormatString)
	base_path_prdtime := base_path_prd + "/" + timestamp

	err := util.Mkdir(base_path_prdtime)
	if err != nil {
		fmt.Fprintf(w, err.Error())
		return err
	}

	base_path_ws := lan.conf.DataPathBase + par.Biz + "/on/workspace/"

	//清理目录
	err = util.KeepLatestN(base_path_prd, 5)
	if err != nil {
		errors.New("[Lands-onlineServeHttp] Clear local file error." + err.Error())
	}

	//读取离线模型
	//优先读取redis
	//挂载数据
	if par.Src == "local" {
		predict_path = base_path_prdtime + "/predict.dat"
		err := util.CopyFile(predict_path, par.Predict)
		if err != nil {
			return errors.New("[Lands-predictServeHttp] copy train data from local to local error." + err.Error())
		}
	} else if par.Src == "hdfs" {
		client, err := lan.createHdfsClient()
		if err != nil {
			return errors.New("[Lands-predictServeHttp] Create hdfs client error." + err.Error())
		}

		predict_path = base_path_prdtime + "/predict.dat"

		client.GetMerge(par.Predict, predict_path, true)
		if err != nil {
			return errors.New("[Lands-predictServeHttp] Getmerge train data from hdfs to local error." + err.Error())
		}

	} else if par.Src == "redis" {
		predict_path = base_path_prdtime + "/predict.dat"
		//redis get with key
	} else {
		// run stream
		instances := strings.Split(strings.TrimSpace(par.Predict), lan.conf.LineSpliter)
		if len(instances) == 0 {
			return errors.New("[Lands-predictServeHttp] Instances number error.")
		}

		json, err := predictor.StreamRun(base_path_ws+"model.dat", instances)
		if err != nil {
			return errors.New("[Lands-predictServeHttp] Predicting running error.")
		}

		fmt.Fprintf(w, json)
		return nil
	}

	json, err := predictor.Run(wr, 3, []string{par.Biz + " predict " + timestamp, predict_path,
		base_path_ws + "model.dat",
		base_path_prdtime + "/predict_result.dat",
		par.Threshold}, fmt.Fprintf)
	if err != nil {
		return errors.New("[Lands-predictServeHttp] Predicting running error.")
	}

	fmt.Fprintf(w, json)

	return nil
}

func (lan *Lands) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	par := util.ParamParse(r)
	fmt.Println(par.String())
	if h, ok := lan.mux[par.Module]; ok {
		err := h(w, par)
		if err != nil {
			fmt.Println(err)
		}
	}

	//    t0 := time.Now()

	//    log4pv := lan.log4pv
	//    log4sys := util.GetLogger()
	//    log4sys.Info("Receive request: %s", r.URL.RawQuery)

	//    if r.Method != "POST" {
	//	fmt.Fprintf(w, ERR_MSG, "Only POST method supported")
	//	return
	//    }

	//    var req LandsRequest
	//    var res LandsResponse
	//    var info_in RankInfoIn
	//    var info_out RankInfoOut

	//    body, err := ioutil.ReadAll(r.Body)
	//    if err != nil {
	//	fmt.Fprintf(w, ERR_MSG, "Read http body error")
	//	return
	//    }

	//    // decoder := json.NewDecoder(r.Body)
	//    // err := decoder.Decode(&req)
	//    err = json.Unmarshal(body, &req)
	//    if err != nil {
	//	log4sys.Error(string(body), err)
	//	fmt.Fprintf(w, ERR_MSG, "Json format error")
	//	return
	//    }

	//    r.ParseForm()

	//    // If "_callback" exists in url, http response is jsonp;
	//    // otherwise http response is json.
	//    var callback string
	//    s := r.Form["_callback"]
	//    if len(s) != 0 {
	//	callback = s[0]
	//    }

	//    err = lan.fillInfoList(&info_in, &req)
	//    if err != nil {
	//	log4sys.Error("[fillInfoList]", err)
	//	Logging(&req, nil, nil, log4pv)
	//	msg := fmt.Sprintf(ERR_MSG, "Internal server error")
	//	httpResponse(w, callback, msg)
	//	return
	//    }

	//    ranker := lan.askPriceRanker
	//    err = ranker.Rank(&info_in, &info_out)
	//    if err != nil {
	//	log4sys.Error("[Rank]", err)
	//	Logging(&req, nil, nil, log4pv)
	//	msg := fmt.Sprintf(ERR_MSG, "Internal server error")
	//	httpResponse(w, callback, msg)
	//	return
	//    }

	//    lan.parseInfoList(&info_out, &res)

	//    b, err := json.Marshal(res)
	//    if err != nil {
	//	log4sys.Error(err)
	//	Logging(&req, &res, &info_out, log4pv)
	//	msg := fmt.Sprintf(ERR_MSG, "Internal server error")
	//	httpResponse(w, callback, msg)
	//	return
	//    }

	//    Logging(&req, &res, &info_out, log4pv)

	//    total_time := time.Now().Sub(t0)
	//    log4sys.Debug("Spend total time", total_time)
	//    if(total_time > lan.thresTime) {
	//	log4sys.Error("Spend total time exceed %d", lan.thresTime)
	//    }

	//    httpResponse(w, callback, string(b))
}
