package predictor

import (
	"io"
	"goline/util"
	"goline/trainer"
	"goline/solver"
	"strconv"
	"runtime"
	"sort"
	"math"
	"os"
)

func print_usage(w io.Writer, argc int, argv[]string, f func (w io.Writer, format string, a ...interface{}) (n int, err error)) {
	f(w,"Usage:\n","", f)
	f(w,"\t%s test_file model output_file threshold\n", argv[0], f)
}

type tuple struct {
	first float64
	second int
}

type tvector []tuple
func (dv tvector) Less(i, j int) bool {
	if dv[i].first < dv[j].first {
		return true
	}
	
	return false
}

func (dv tvector) Len() int {  
    return len(dv)  
}

func (dv tvector) Swap(i, j int) {  
    var temp tuple = dv[i]  
    dv[i] = dv[j]  
    dv[j] = temp  
}

func tied_rank(x []float64) []float64 {
	
	var sorted_x tvector = make([]tuple, len(x))
	for i:=0; i<len(x); i++ {
		sorted_x[i] = tuple{x[i], i}
	}
	
	sort.Sort(sorted_x)
	
	r := make([]float64, len(x))
	cur_val := sorted_x[0].first
	last_rank := 0
	for i:=0; i<len(sorted_x); i++ {
		if cur_val != sorted_x[i].first {
			cur_val = sorted_x[i].first
			for j:=last_rank; j<i; j++ {
				r[sorted_x[j].second] = float64(last_rank+1+i)/2.0
			}
			last_rank = i
		}
		
		if i==len(sorted_x)-1 {
			for j:=last_rank; j<i+1; j++ {
				r[sorted_x[j].second] = float64(last_rank+i+2)/2.0
			}
		}
	}
	
	return r
}

func auc(w io.Writer, actual []float64, posterior []float64, f func (w io.Writer, format string, a ...interface{}) (n int, err error)) float64 {
	r := tied_rank(posterior)
	num_positive := 0.
	sum_positive := 0.
	for i:=0; i<len(actual); i++ {
		if actual[i] == 1 {
			num_positive++
		}
	}
	
	num_negative := float64(len(actual))-num_positive
	for i:=0; i<len(r); i++ {
		if actual[i] == 1 {
			sum_positive += r[i]
		}
	}

	if num_negative*num_positive < 0.00001 {
		f(w, "num_positive %d, num_negative %d, sum_positive%d\n",num_positive,num_negative,sum_positive)
		return 0.
	}

	auc := ((sum_positive - num_positive*(num_positive+1)/2.0) /
		(num_negative*num_positive))
		
	return auc
}

func calc_auc(w io.Writer, scores util.Dvector, f func (w io.Writer, format string, a ...interface{}) (n int, err error)) float64 {
	var label []float64
	var predict []float64
	
	for i:=0; i<len(scores); i++ {
		label = append(label, scores[i].Second)
		predict = append(predict, scores[i].First)
	}

	auc := auc(w, label,predict, f)
	return auc
}

func Run(w io.Writer, argc int, argv[]string, f func (w io.Writer, format string, a ...interface{}) (int, error)) (int, error){

	var test_file string
	var model_file string
	var output_file string
	var threshold float64

	if len(argv) == 4 {
		test_file = argv[0]
		model_file = argv[1]
		output_file = argv[2]
		threshold, _ = strconv.ParseFloat(argv[3], 64)
	} else {		
		print_usage(w, argc, argv, f)
		runtime.Goexit()
	}

	if len(test_file) == 0 || len(model_file) == 0 || len(output_file) == 0 {
		print_usage(w, argc, argv, f)
		runtime.Goexit()
	}

	var model solver.LRModel
	model.Initialize(model_file)
	
	var wfp *os.File
	var err1 error
	exist := func(filename string) (bool) {
		var exist = true
		if _, err := os.Stat(filename); os.IsNotExist(err) {
	  		exist = false
	 	}
	 	return exist
	}
	
	if exist(output_file) {
  		wfp, err1 = os.OpenFile(output_file, os.O_SYNC , 0666)
 	} else {
  		wfp, err1 = os.Create(output_file)
 	}
	
	if err1 != nil {
		return 255, err1
    }
	
 	defer wfp.Close()
	
	cnt := 0		//样本总数
	pcorrect := 0	//正样本预测正确数
	pcnt := 0		//正样本总数
	ncorrect := 0	//负样本预测正确数
	var loss float64 = 0.
	var parser trainer.FileParser
	parser.OpenFile(test_file)

	var pred_scores util.Dvector

	for {
		res, y, x := parser.ReadSample()
		if !res {
			break
		}

		pred := model.Predict(x)
		pred = math.Max(math.Min(pred, 1. - 10e-15), 10e-15)
		f(wfp, "%f\n", pred)

		pred_scores = append(pred_scores, util.DPair{pred, y})

		cnt++
		if util.UtilFloat64Equal(y, 1.0) {
			pcnt++
		}
		
		var pred_label float64 = 0
		if pred > threshold {
			pred_label = 1
		}
			
		if util.UtilFloat64Equal(pred_label, y) {
			if util.UtilFloat64Equal(y, 1.0) {
				pcorrect++
			} else {
				ncorrect++
			}
		}

		pred = math.Max(math.Min(pred, 1. - 10e-15), 10e-15)
		if y > 0 {
			loss += -math.Log(pred)
		} else {
			loss += -math.Log(1. - pred)
		}		
	}
	
	auc := calc_auc(w, pred_scores, f)

	if (cnt > 0) {
		f(w, "Log-likelihood = %f\n", float64(loss) / float64(cnt))
		f(w, "Precision = %.2f%% (%d/%d)\n",
			float64(pcorrect * 100) / float64(cnt-pcnt-ncorrect+pcorrect), pcorrect, cnt-pcnt-ncorrect+pcorrect)
		f(w, "Recall = %.2f%% (%d/%d)\n",
			float64(pcorrect * 100) / float64(pcnt), pcorrect, pcnt)
		f(w, "Accuracy = %.2f%% (%d/%d)\n",
			float64((pcorrect+ncorrect) * 100) / float64(cnt), (pcorrect+ncorrect), cnt)
		f(w, "AUC = %f\n", auc)
	}

	parser.CloseFile()

	return 0, nil
}
