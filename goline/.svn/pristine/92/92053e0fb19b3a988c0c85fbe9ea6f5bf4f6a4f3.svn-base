package solver

import (
	"goline/util"
	"sync"
	"math"
)

const (
	ParamGroupSize = 10
	FetchStep = 3
	PushStep = 3
)

func calc_group_num(n int) int {
	return (n + ParamGroupSize - 1) / ParamGroupSize
}

type FtrlParamServer struct {
	FtrlSolver
	
	ParamGroupNum int
	LockSlots []sync.Mutex
}

type FtrlWorker struct {
	FtrlSolver
	
	ParamGroupNum int
	ParamGroupStep []int
	PushStep int
	FetchStep int

	NUpdate []float64
	ZUpdate []float64
}

func (fps *FtrlParamServer) Initialize (
		alpha float64,
		beta float64,
		l1 float64,
		l2 float64,
		n int,
		dropout float64) bool {
	if !fps.FtrlSolver.Initialize(alpha, beta, l1, l2, n, dropout) {
		return false
	}

	fps.ParamGroupNum = calc_group_num(n)
	fps.LockSlots = make([]sync.Mutex, fps.ParamGroupNum)

	fps.Init = true
	return true
}

func (fps *FtrlParamServer) Construct(path string) bool {
	if !fps.FtrlSolver.Construct(path) {
		return false
	}

	fps.ParamGroupNum = calc_group_num(fps.FtrlSolver.Featnum)
	fps.LockSlots = make([]sync.Mutex, fps.ParamGroupNum)

	fps.Init = true
	return true
}

func (fps *FtrlParamServer) FetchParamGroup(n []float64, z []float64, group int) bool {
	if !fps.FtrlSolver.Init {
		return false
	}

	var start int = group * ParamGroupSize
	var end int = util.MinInt((group + 1) * ParamGroupSize, fps.FtrlSolver.Featnum)

	fps.LockSlots[group].Lock()
	for i := start; i < end; i++ {
		n[i] = fps.FtrlSolver.N[i]
		z[i] = fps.FtrlSolver.Z[i]
	}
	fps.LockSlots[group].Unlock()

	return true
}

func (fps *FtrlParamServer) FetchParam(n []float64, z []float64) bool {
	if !fps.FtrlSolver.Init {
		return false
	}

	for i := 0; i < fps.ParamGroupNum; i++ {
		fps.FetchParamGroup(n, z, i)
	}
	return true
}

func (fps *FtrlParamServer) PushParamGroup(n []float64, z []float64, group int) bool {
	if !fps.FtrlSolver.Init {
		return false
	}

	var start int = group * ParamGroupSize
	var end int =util.MinInt((group + 1) * ParamGroupSize, fps.FtrlSolver.Featnum)

	fps.LockSlots[group].Lock()
	for i := start; i < end; i++ {
		fps.FtrlSolver.N[i] += n[i]
		fps.FtrlSolver.Z[i] += z[i]
		n[i] = 0
		z[i] = 0
	}
	fps.LockSlots[group].Unlock()
	return true
}


func (fw *FtrlWorker) Initialize (
		param_server *FtrlParamServer,
		push_step int,
		fetch_step int) bool {
			
	fw.FtrlSolver.Alpha = param_server.Alpha
	fw.FtrlSolver.Beta = param_server.Beta
	fw.FtrlSolver.L1 = param_server.L1
	fw.FtrlSolver.L2 = param_server.L2
	fw.FtrlSolver.Featnum = param_server.Featnum
	fw.FtrlSolver.Dropout = param_server.Dropout

	fw.NUpdate = make([]float64, fw.FtrlSolver.Featnum)
	fw.ZUpdate = make([]float64, fw.FtrlSolver.Featnum)
	fw.SetFloatZero(fw.NUpdate, fw.FtrlSolver.Featnum)
	fw.SetFloatZero(fw.ZUpdate, fw.FtrlSolver.Featnum)

	fw.N = make([]float64, fw.FtrlSolver.Featnum)
	fw.Z = make([]float64, fw.FtrlSolver.Featnum)
	param_server.FetchParam(fw.N, fw.Z)

	fw.ParamGroupNum = calc_group_num(fw.FtrlSolver.Featnum)
	fw.ParamGroupStep = make([]int, fw.ParamGroupNum)
	for i := 0; i < fw.ParamGroupNum; i++ {
		fw.ParamGroupStep[i] = 0
	}

	fw.PushStep = push_step
	fw.FetchStep = fetch_step

	fw.FtrlSolver.Init = true
	return fw.FtrlSolver.Init
}

func (fw *FtrlWorker) Reset(param_server *FtrlParamServer) bool {
	if !fw.FtrlSolver.Init {
		return false
	}

	param_server.FetchParam(fw.FtrlSolver.N, fw.FtrlSolver.Z)

	for i := 0; i < fw.ParamGroupNum; i++ {
		fw.ParamGroupStep[i] = 0
	}
	return true
}

func (fw *FtrlWorker) Update(
		x util.Pvector,
		y float64,
		param_server *FtrlParamServer) float64 {
	
	if !fw.FtrlSolver.Init {
		return 0.
	}

	var weights util.Pvector = make(util.Pvector, fw.FtrlSolver.Featnum)
	var gradients []float64 = make([]float64, fw.FtrlSolver.Featnum)
	var wTx float64 = 0.

	for i:=0; i<len(x); i++ {
		item := x[i]
		if util.UtilGreater(fw.FtrlSolver.Dropout, 0.0) {
			rand_prob := util.UniformDistribution()
			if (rand_prob < fw.FtrlSolver.Dropout) {
				continue
			}
		}
		var idx int = item.Index
		if (idx >= fw.FtrlSolver.Featnum) {
			continue
		}

		//获取w权重值
		var val float64 = fw.FtrlSolver.GetWeight(idx)
		//建立w权重数组
		weights = append(weights, util.Pair{idx, val})
		//每个样本梯度值默认赋值为样本x本身
		gradients = append(gradients,item.Value)
		//计算仿射函数wT*x的值		
		wTx += val * item.Value		
	}

	//计算模型预估值
	var pred float64 = util.Sigmoid(wTx)
	//计算p_t-y_t值，为计算每个样本的梯度做准备
	var grad float64 = pred - y
	//计算g_i = (p_t-y_t)*x_i
	util.VectorMultiplies(gradients, grad)

	for k := 0; k < len(weights); k++ {
		var i int = weights[k].Index
		var g int = i / ParamGroupSize

		if (fw.ParamGroupStep[g] % fw.FetchStep == 0) {		
			param_server.FetchParamGroup(
				fw.FtrlSolver.N,
				fw.FtrlSolver.Z,
				g)				
		}		

		var w_i float64 = weights[k].Value
		var grad_i float64 = gradients[k]
		var sigma float64 = (math.Sqrt(fw.FtrlSolver.N[i] + grad_i * grad_i) - math.Sqrt(fw.FtrlSolver.N[i])) / fw.FtrlSolver.Alpha

		fw.FtrlSolver.Z[i] += grad_i - sigma * w_i
		fw.FtrlSolver.N[i] += grad_i * grad_i
		fw.ZUpdate[i] += grad_i - sigma * w_i
		fw.NUpdate[i] += grad_i * grad_i

		if fw.ParamGroupStep[g] % fw.PushStep == 0 {
			param_server.PushParamGroup(fw.NUpdate, fw.ZUpdate, g)
		}

		fw.ParamGroupStep[g] += 1
	}

	return pred
}

func (fw *FtrlWorker) PushParam(param_server *FtrlParamServer) bool {
	if !fw.FtrlSolver.Init {
		return false
	}

	for i := 0; i < fw.ParamGroupNum; i++ {
		param_server.PushParamGroup(fw.NUpdate, fw.ZUpdate, i)
	}

	return true
}
