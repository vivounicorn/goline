package trainer

import (
	"os"
	"log"
	"sync"
	"ftrl_proximal/util"
	s "strings"
	"bufio"
	"io"
)

type FileParser struct {
	Buf string
	BufSize int
	Fs *os.File
	Bufio *bufio.Reader
	Lock sync.Mutex
}

func (fp *FileParser) FileExists(filename string) bool {
	fs, err := os.Open(filename)
	if err != nil {
		log.Println("Open file failed:", err)
		return false
	}
	
	defer fs.Close()
	return true
}

func (fp *FileParser) OpenFile(filename string) bool {
	fs, err := os.Open(filename)
	if err != nil {
		log.Println("Open file failed:", err)
		return false
	}
	
	fp.Fs = fs	
	fp.Bufio =bufio.NewReader(fs)
	return true
}

func (fp *FileParser) CloseFile() bool {
	if fp.Fs != nil {
		defer fp.Fs.Close()
	}

	return true
}

func (fp *FileParser) ReadLineImpl() string {
	line, err := fp.Bufio.ReadString('\n')
	line = s.TrimSpace(line)
  	if err != nil { //遇到任何错误立即返回，并忽略 EOF 错误信息
   		if err == io.EOF {
    		return "0"
		} else {
			return "-1"
		}
	}
	
	return line
}

func (fp *FileParser) ReadLine() string {
	fp.Lock.Lock()
	buf := fp.ReadLineImpl()
	fp.Lock.Unlock()
	if buf != "0" && buf != "-1" {
		return buf
	}
	
	return ""
}

func (fp *FileParser) ReadSample() (bool, float64, util.Pvector){
	fp.Lock.Lock()
	buf := fp.ReadLineImpl()
	fp.Lock.Unlock()
	if buf == "0" || buf == "-1" {
		return false, 0., nil
	}
	
	return util.ParseSample(buf)
}

func (fp *FileParser) ReadSampleMultiThread() (bool, float64, util.Pvector) {
	buf := fp.ReadLine()
	if len(buf) == 0 {
		return false, 0., nil
	}
	
	return util.ParseSample(buf)
}